#+TITLE: lemonade

Experiment in higher order visual programming.

* Overview
	This is both a library for doing vector graphics in a data driven idiomatic
	clojure fashion and a framework for making interactive graphics / animations /
	UIs using that library.

	These two parts will likely be separated at a future date, but since the is
	mostly an experiment at present, it's far more convenient to keep them
	together.

* Breakdown
	The core graphics primitives are in =lemonade.core=.

	Renderers are in =lemonade.renderers.*=. There are currently only 2, an HTML
	Canvas 2d rendering context renderer for the browser and a quil renderer for
	JVM Clojure.

	Demo setups of the two renderers are in =lemonade.demos.*=, and examples that
	*should* work in either are in =lemonade.examples.*=

* Getting Started
** Install
	 To get an interactive development environment run:

	 lein figwheel

	 and open your browser at [localhost:3449](http://localhost:3449/).  This will
	 auto compile and send all changes to the browser without the need to
	 reload. After the compilation process is complete, you will get a Browser
	 Connected REPL. An easy way to try it is:

	 (js/alert "Am I connected?")

	 and you should see an alert in the browser window.

	 To clean all compiled files:

	 lein clean

	 To create a production build run:

	 lein do clean, cljsbuild once min

	 And open your browser in =resources/public/index.html=. You will not get live
	 reloading, nor a REPL.

** Play
	 There isn't any good way to switch between examples just yet. Look at
	 whatever function defines =lemonade.demos.canvas/base= and play with it, the
	 changes should update automatically.

* Development
** Demo
	 I think the best demo would show what the system can do, explain how it's
	 different that makes it possible, and shows interactively how it works.

	 I have this vague notion of multilevel documents that have content,
	 metacontent, etc. where you can go from tldr to intensely detailed through a
	 series of "show me more" type requests.

	 The problem is that I have too many ideas and they all reach in different
	 directions.

	 What am I building?
** Actions needed
*** DONE Text
		 CLOSED: [2017-11-28 Tue 11:58]
*** DONE Finish Elections Demo
		 CLOSED: [2017-11-28 Tue 11:57]
		This has lots of little bits that are needed for polish
*** TODO Pacman
		Not the full game, just enough to force test lazy animations and
		interactivity.
*** TODO Second Implementation
		The Quil based JVM renderer is just a stub really. I need a second
		implementation to call me out anywhere I might be thinking in terms of
		canvas.
*** TODO Animations in event loop
		If the app state doesn't change then render won't be called. So interactive
		animations need to return a lazy seq of frames which will be poped off by
		the event loop event if the app state hasn't changed. Of course whatever
		makes this lazy-seq will need to be aware of game time.

		I don't know how to do this. Yet another experiment.
*** TODO Lazy rendering
*** TODO Direct bitmaps
		Some operations are too expensive for a vector representation. Some things
		(like the Mandlebrot set) are defined pixelwise, and I don't know that
		trying to redefine them would be productive.

		So, play around and try to find idioms that are productive and fit.

*** TODO Physics
*** TODO Text boxes
		Given a long string and a bounding shape, we should be able to do things
		like wrapping and justifying.
*** TODO Demo animation / game
		The line between the two can be very blurry if we think of physics as
		strictly Newtonian. Without input from the user, the "game" is an animation
		since the physics are all deterministic.

		This might be a terrible way to make games, but it might also work. Fun test.

*** TODO Render caching
		The renderer is reasonably fast, but will choke on complicated things.
*** TODO Draw a map from GIS data
		Elections Canada released an enourmous KML file containing the boundaries of
		every polling station of every riding in the country. That could make a very
		detailed map. Can I render that on the fly? Think of it as a stress test.
*** TODO Proceedural Drawing
		This is a big one, but too hard to insist that it be required.

		I'd like to come up with a way to create a declarative spec of a proceedural
		drawing that the runtime can compile with perlin noise into a lemonade
		shape.

		That can be done offline and the shapes can be hotloaded in the client if
		need be.

		How does one declaratively specify a proceedural drawing?!?

** References
	 - [[https://www.html5rocks.com/en/tutorials/canvas/performance/][Canvas performance techniques]]
		 If optimisation becomes necessary

* Notable flaws
** Zoom misbehaviour
	 Zoom only works in the range of about [-9000 9000]. That's ~[1e-40 1e38].

	 I don't know why that is. It's nowhere near the precision limit of floats,
	 let alone doubles. What's most fascinating is that when you multiply the zoom
	 matrix by the scale matrix at the limit you get values on the order of 0.3!
	 perfectly precise for our application.

	 Maybe this is a limit in the significant part, not the exponential part. That
	 would align roughly with the failure conditions.

	 So I need to look for some mathematical trick to not recover small numbers by
	 multiplying really big ones and really small ones. That sounds hard. I also
	 don't know that it will solve my problem. Better diagnosis tools would be in
	 order.

	 A zoom scale of ~100 doublings isn't that bad. For the time being I can make
	 progress by just bounding the zoom.
** Windowing [2017-12-02 Sat 12:15]
	 At present we can render effectively infinite drawings by having the base
	 image handler refer to the window data and decide what to show based on the
	 current window position.

	 This works, but it needlessly couples the window handling with the
	 image. Furthermore, it means that we can't use the image in a static
	 windowless context without stubbing out a window. Of course that's kind of
	 obvious that you need to choose a window to determine what you see, but at
	 the same time the coupling in code between the so called framework piece and
	 the business logic is ugly.

	 In principle we should be able to compute the extent of a vo and decide in
	 the runtime whether to render it or not. This is the kind of global
	 optimisation that can pay huge returns potentially, but how can we do it?

	 The only way that I can figure is to make a new kind of composite which knows
	 its extent. Its children can in turn be of the same sort. In this way an
	 image with infinite content can be represented by a lazy tree and rendering
	 will get cut off at the point where an element and all its children are
	 invisible.

	 This doesn't solve the problem of images that are infinite in extent, like
	 grid lines, or images that are unreasonably large in extent like a highly
	 zoomed in mandlebrot set.

	 Maybe the concept of window needs to be fundamental to the framework. You may
	 not need the dynamic window interaction, but you do need to specify the
	 mapping from real space into coordinate space. Everything depends on that, so
	 that dependency should be explicit.

	 Things are getting less and less declarative as we go. This is going to make
	 my life more difficult. Especially in regards to automatic code
	 simplification.
* License

	Copyright Â© 2017 Thomas Getgood

	Distributed under the Eclipse Public License either version 1.0 or (at your
	option) any later version.
